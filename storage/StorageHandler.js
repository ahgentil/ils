// Generated by CoffeeScript 1.9.0
(function() {
  "use strict";
  var ErrorHandler, dummy, goLabLocalStorageKey,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  window.golab = window.golab || {};

  window.golab.ils = window.golab.ils || {};

  window.golab.ils.storage = window.golab.ils.storage || {};

  window.golab.ils.storage.memory = window.golab.ils.storage.memory || {};

  dummy = {
    metadata: {},
    support: {}
  };


  /*
    Superclass for all storage handlers.
    A resource has the structure { id, content: {}, metadata: {} }.
   */

  window.golab.ils.storage.StorageHandler = (function() {
    function StorageHandler(metadataHandler, _at__filterForResourceType, _at__filterForUser, _at__filterForProvider, _at__customFilter, _at__filterForAppId) {
      var error;
      this._filterForResourceType = _at__filterForResourceType != null ? _at__filterForResourceType : true;
      this._filterForUser = _at__filterForUser != null ? _at__filterForUser : true;
      this._filterForProvider = _at__filterForProvider != null ? _at__filterForProvider : true;
      this._customFilter = _at__customFilter != null ? _at__customFilter : null;
      this._filterForAppId = _at__filterForAppId != null ? _at__filterForAppId : true;
      this.createResource = __bind(this.createResource, this);
      this.readLatestResource = __bind(this.readLatestResource, this);
      this.getResourceBundle = __bind(this.getResourceBundle, this);
      this.applyFilters = __bind(this.applyFilters, this);
      this.className = "golab.ils.storage.StorageHandler";
      this._debug = true;
      if (this._debug) {
        console.log("Initializing StorageHandler.");
      }
      this._lastResourceId = void 0;
      try {
        metadataHandler.getMetadata();
        this.metadataHandler = metadataHandler;
      } catch (_error) {
        error = _error;
        throw "StorageHandler needs a MetadataHandler at construction!";
      }
      this._isReadOnly = false;
      this.checkWritePermission();
      if (this._debug) {
        console.log("...StorageHandler is readOnly? -> " + this.isReadOnly());
      }
    }

    StorageHandler.prototype.checkWritePermission = function() {
      this._isReadOnly = false;
      return;
      if (this.metadataHandler.getMetadata().contextualActor != null) {
        return this._isReadOnly = true;
      } else if (this.metadataHandler.getActor().objectType === "graasp_viewer") {
        return this._isReadOnly = true;
      } else {
        return this._isReadOnly = false;
      }
    };


    /*
      Returns a boolean value to indicate if the StorageHandler is running in readOnly mode.
      In readOnly mode, calls to createResource, updateResource and deleteResource
      are doing nothing and return an error instead.
     */

    StorageHandler.prototype.isReadOnly = function() {
      return this._isReadOnly;
    };


    /*
      (newValue: boolean)
      Sets the internal _isReadOnly variable to a new value to override the initial setting at construction time.
      Be careful with this function, as it may cause problems when you don't have write permissions to an "external" storage.
     */

    StorageHandler.prototype.setReadOnly = function(newValue) {
      return this._isReadOnly = newValue;
    };

    StorageHandler.prototype.getDebugLabel = function() {
      return this.className + "(" + (this.metadataHandler.getTarget().objectType) + ")";
    };

    StorageHandler.prototype.generateUUID = function() {
      return this.metadataHandler.generateUUID();
    };

    StorageHandler.prototype.configureFilters = function(filterForResourceType, filterForUser, filterForProvider, filterForAppId) {
      if (filterForAppId == null) {
        filterForAppId = true;
      }
      this._filterForResourceType = filterForResourceType;
      this._filterForUser = filterForUser;
      this._filterForProvider = filterForProvider;
      return this._filterForAppId = filterForAppId;
    };

    StorageHandler.prototype.setForResourceTypeFilter = function(filterForResourceType) {
      return this._filterForResourceType = filterForResourceType;
    };

    StorageHandler.prototype.getForResourceTypeFilter = function() {
      return this._filterForResourceType;
    };

    StorageHandler.prototype.setForUserFilter = function(filterForUser) {
      return this._filterForUser = filterForUser;
    };

    StorageHandler.prototype.getForUserFilter = function() {
      return this._filterForUser;
    };

    StorageHandler.prototype.setForProviderFilter = function(filterForProvider) {
      return this._filterForProvider = filterForProvider;
    };

    StorageHandler.prototype.getForProviderFilter = function() {
      return this._filterForProvider;
    };

    StorageHandler.prototype.setForAppIdFilter = function(filterForAppId) {
      return this._filterForAppId = filterForAppId;
    };

    StorageHandler.prototype.getForAppIdFilter = function() {
      return this._filterForAppId;
    };

    StorageHandler.prototype.setCustomFilter = function(customFilter) {
      return this._customFilter = customFilter;
    };

    StorageHandler.prototype.getCustomFilter = function() {
      return this._customFilter;
    };

    StorageHandler.prototype.getMetadataHandler = function() {
      return this.metadataHandler;
    };

    StorageHandler.prototype.getResourceDescription = function(resource) {
      var author, errorAnswer, id, metadata, modified, title, tool, type;
      errorAnswer = function(noLabel) {
        var errorMessage;
        errorMessage = "unknown, no " + noLabel;
        return {
          id: errorMessage,
          title: errorMessage,
          type: errorMessage,
          tool: errorMessage,
          author: errorMessage,
          modified: errorMessage
        };
      };
      if (!resource) {
        return errorAnswer("resource");
      } else if (!resource.metadata) {
        return errorAnswer("metadata");
      } else {
        metadata = resource.metadata;
        id = metadata.id ? metadata.id : "";
        title = metadata.target && metadata.target.displayName ? metadata.target.displayName : "";
        type = metadata.target && metadata.target.objectType ? metadata.target.objectType : "";
        tool = metadata.generator && metadata.generator.displayName ? metadata.generator.displayName : "";
        author = metadata.actor && metadata.actor.displayName ? metadata.actor.displayName : "";
        modified = metadata.published ? new Date(resource.metadata.published) : new Date();
        return {
          id: id,
          title: title,
          type: type,
          tool: tool,
          author: author,
          modified: modified
        };
      }
    };

    StorageHandler.prototype.applyFilters = function(metadatas) {
      if (this._debug) {
        console.log("StorageHandler.applyFilters:");
        console.log("filter for type (" + (this.metadataHandler.getTarget().objectType) + "): " + this._filterForResourceType + ", user: " + this._filterForUser + ", appId: " + this._filterForAppId + ", provider: " + this._filterForProvider);
        console.log(metadatas);
      }
      if (this._filterForResourceType) {
        metadatas = metadatas.filter((function(_this) {
          return function(entry) {
            return entry.metadata.target.objectType === _this.metadataHandler.getTarget().objectType;
          };
        })(this));
      }
      if (this._filterForProvider) {
        metadatas = metadatas.filter((function(_this) {
          return function(entry) {
            return entry.metadata.provider.id === _this.metadataHandler.getProvider().id;
          };
        })(this));
      }
      if (this._filterForUser) {
        if (this.metadataHandler.getMetadata().contextualActor != null) {
          metadatas = metadatas.filter((function(_this) {
            return function(entry) {
              return entry.metadata.actor.displayName === _this.metadataHandler.getMetadata().contextualActor.displayName;
            };
          })(this));
        } else {
          metadatas = metadatas.filter((function(_this) {
            return function(entry) {
              return entry.metadata.actor.displayName === _this.metadataHandler.getActor().displayName;
            };
          })(this));
        }
      }
      if (this._filterForAppId) {
        metadatas = metadatas.filter((function(_this) {
          return function(entry) {
            return entry.metadata.generator.id === _this.metadataHandler.getGenerator().id;
          };
        })(this));
      }
      if (this._customFilter) {
        metadatas = metadatas.filter((function(_this) {
          return function(entry) {
            return _this._customFilter(entry.metadata);
          };
        })(this));
      }
      if (this._debug) {
        console.log("after: ");
        console.log(metadatas);
      }
      return metadatas;
    };

    StorageHandler.prototype.getResourceBundle = function(content, id) {
      var metadata, thisContent;
      if (id == null) {
        id = this.generateUUID();
      }
      thisContent = JSON.parse(JSON.stringify(content));
      metadata = JSON.parse(JSON.stringify(this.metadataHandler.getMetadata()));
      if (metadata.contextualActor != null) {
        metadata.actor = metadata.contextualActor;
        metadata.contextualActor = void 0;
      }
      metadata.published = (new Date()).toISOString();
      metadata.id = id;
      return {
        metadata: metadata,
        content: thisContent
      };
    };

    StorageHandler.prototype._findLatestResourceId = function(objectType, metadatas) {
      var date, entry, latestDate, latestId, _i, _len;
      if (this._debug) {
        console.log("_findLatestResourceId(" + objectType + ", " + metadatas.length + ")");
      }
      latestDate = new Date(1970, 0, 1);
      latestId = void 0;
      for (_i = 0, _len = metadatas.length; _i < _len; _i++) {
        entry = metadatas[_i];
        if ((objectType != null) && objectType !== entry.metadata.target.objectType) {
          continue;
        }
        if (entry.metadata.published != null) {
          date = new Date(entry.metadata.published);
          if (date > latestDate) {
            latestDate = date;
            latestId = entry.metadata.id;
          }
        }
      }
      return latestId;
    };

    StorageHandler.prototype.readLatestResource = function(objectType, cb) {
      if (this._debug) {
        console.log("StorageHandler: searching for latest resource of type '" + objectType + "'");
      }
      return this.listResourceMetaDatas((function(_this) {
        return function(error, metadatas) {
          var date, entry, latestDate, latestId, _i, _len;
          if (error != null) {
            return setTimeout(function() {
              if (this._debug) {
                console.log("StorageHandler: an error occured: " + error);
              }
              return cb(error, void 0);
            }, 0);
          } else {
            if (_this._debug) {
              console.log("StorageHandler: found resources:");
              console.log(metadatas);
            }
            latestDate = new Date(1970, 0, 1);
            latestId = void 0;
            for (_i = 0, _len = metadatas.length; _i < _len; _i++) {
              entry = metadatas[_i];
              if ((objectType != null) && objectType !== entry.metadata.target.objectType) {
                continue;
              }
              if (entry.metadata.published != null) {
                date = new Date(entry.metadata.published);
                if (date > latestDate) {
                  latestDate = date;
                  latestId = entry.metadata.id;
                }
              }
            }
            if (latestId != null) {
              if (_this._debug) {
                console.log("StorageHandler: now reading " + latestId);
              }
              return _this.readResource(latestId, cb);
            } else {
              return setTimeout(function() {
                return cb(null, null);
              }, 0);
            }
          }
        };
      })(this));
    };


    /*
      Reads a resource with a given id.
      Takes a callback with (err, resource). err is null or contains the error if
      any error occured. It is an error if there is no resource with given id.
     */

    StorageHandler.prototype.readResource = function(resourceId, cb) {
      throw "Abstract function readResource - implement in subclass.";
    };


    /*
      Checks if there is a resource with given id.
      Takes a callback with (err, exists), where exists is true when there is a
      resource with given id, and false otherwise. err is null or contains the
      error if any error occured.
     */

    StorageHandler.prototype.resourceExists = function(resourceId, cb) {
      throw "Abstract function resourceExists - implement in subclass.";
    };


    /*
      Creates a resource with the given content.
      Takes a callback with (err, resource), where resource is the newly created
      resource. err is null or contains the error if any error occured.
     */

    StorageHandler.prototype.createResource = function(content, cb) {
      throw "Abstract function createResource - implement in subclass.";
    };


    /*
      Updates an existing resource with new content.
      Takes a callback with(err, resource), where resource is the updated
      resource. err is null or contains the error if any error occured.
     */

    StorageHandler.prototype.updateResource = function(resourceId, content, cb) {
      throw "Abstract function updateResource - implement in subclass.";
    };


    /*
      Deletes an existing resource.
      Requires the resourceId of the resource to be deleted,
      and a callback that returns an error if something went wrong,
      or is null on success.
      resource. err is null or contains the error if any error occured.
     */

    StorageHandler.prototype.deleteResource = function(resourceId, cb) {
      throw "Abstract function deleteResource - implement in subclass.";
    };


    /*
      Calls back with the ids of all existing resources.
      Takes a callback with (err, ids). err is null or contains the error if any
      error occured.
     */

    StorageHandler.prototype.listResourceIds = function(cb) {
      throw "Abstract function listResourceIds - implement in subclass.";
    };


    /*
      Calls back with the metadata of all existing resources.
      Takes a callback with (err, metadatas), where metadatas is an Array of
      { id, metadata: {} } objects. err is null or contains the error if any error
      occured. The metadatas are (potentially) filtered for username, resource type, and provider id.
     */

    StorageHandler.prototype.listResourceMetaDatas = function(cb) {
      throw "Abstract function listResourceMetaDatas - implement in subclass.";
    };

    return StorageHandler;

  })();


  /*
    This is an optional call, which is needed if you want to use the CachingStorageHandler.
    Calls back with all (relevant) resources to cache at the client side.
    This means all resources for the current user for all tools.
    If desired, the content part of the resources can be skipped.
    Takes a callback with (err, metadatas), where metadatas is an Array of
    { id, metadata: {} } objects. err is null or contains the error if any error
    occured. The metadatas are (potentially) filtered for username, resource type, and provider id.
   */


  /*
    Implementation of an object storage handler
   */

  window.golab.ils.storage.ObjectStorageHandler = (function(_super) {
    __extends(ObjectStorageHandler, _super);

    function ObjectStorageHandler(metadataHandler, storeObject) {
      this.listResourceMetaDatas = __bind(this.listResourceMetaDatas, this);
      this.createResource = __bind(this.createResource, this);
      ObjectStorageHandler.__super__.constructor.apply(this, arguments);
      if (typeof storeObject !== "object") {
        throw "you must pass on an object to store the resources";
      }
      this.storeObject = storeObject;
      if (this._debug) {
        console.log("Initializing ObjectStorageHandler.");
      }
      this;
    }

    ObjectStorageHandler.prototype.readResource = function(resourceId, cb) {
      var error;
      if (this.storeObject[resourceId]) {
        if (this._debug) {
          console.log("MemoryStorage: readResource " + resourceId);
        }
        return setTimeout(function() {
          return cb(null, JSON.parse(JSON.stringify(this.storeObject[resourceId])));
        }, 0);
      } else {
        error = new Error("MemoryStorage: readResource " + resourceId + " not found.");
        if (this._debug) {
          console.log(error);
        }
        return setTimeout(function() {
          return cb(error);
        }, 0);
      }
    };

    ObjectStorageHandler.prototype.resourceExists = function(resourceId, cb) {
      var exists;
      exists = this.storeObject[resourceId] !== void 0;
      return cb(null, exists);
    };

    ObjectStorageHandler.prototype.createResource = function(content, cb) {
      var error, resource;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      try {
        resource = this.getResourceBundle(content);
        if (this.storeObject[resource.metadata.id]) {
          error = new Error("MemoryStorage: resource already exists! " + resource.metadata.id);
          if (this._debug) {
            console.log(error);
          }
          return setTimeout(function() {
            return cb(error);
          }, 0);
        } else {
          this.storeObject[resource.metadata.id] = resource;
          if (this._debug) {
            console.log("MemoryStorage: resource created: " + resource);
          }
          if (this._debug) {
            console.log(resource);
          }
          return setTimeout(function() {
            return cb(null, resource);
          }, 0);
        }
      } catch (_error) {
        error = _error;
        error = new Error("MemoryStorage: resource NOT created: " + error);
        if (this._debug) {
          console.log(error);
        }
        return setTimeout(function() {
          return cb(error);
        }, 0);
      }
    };

    ObjectStorageHandler.prototype.updateResource = function(resourceId, content, cb) {
      var error, resource;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      if (this.storeObject[resourceId]) {
        resource = this.getResourceBundle(content, resourceId);
        this.storeObject[resourceId] = resource;
        if (this._debug) {
          console.log("MemoryStorage: updateResource " + resourceId);
        }
        return setTimeout(function() {
          return cb(null, resource);
        }, 0);
      } else {
        error = new Error("MemoryStorage: updateResource failed, resource doesn't exist: " + resourceId);
        console.log(error);
        return setTimeout(function() {
          return cb(error);
        }, 0);
      }
    };

    ObjectStorageHandler.prototype.listResourceIds = function(cb) {
      var id, ids, resource;
      ids = (function() {
        var _ref, _results;
        _ref = this.storeObject;
        _results = [];
        for (id in _ref) {
          resource = _ref[id];
          _results.push(id);
        }
        return _results;
      }).call(this);
      return setTimeout(function() {
        return cb(null, ids);
      }, 0);
    };

    ObjectStorageHandler.prototype.listResourceMetaDatas = function(cb) {
      var id, metadatas, resource, _ref;
      metadatas = [];
      _ref = this.storeObject;
      for (id in _ref) {
        resource = _ref[id];
        metadatas.push({
          id: id,
          metadata: JSON.parse(JSON.stringify(resource.metadata))
        });
      }
      metadatas = this.applyFilters(metadatas);
      return setTimeout(function() {
        return cb(null, metadatas);
      }, 0);
    };

    return ObjectStorageHandler;

  })(window.golab.ils.storage.StorageHandler);


  /*
    Implementation of a memory storage handler, which is a subclass of the object storage handler.
   */

  window.golab.ils.storage.MemoryStorageHandler = (function(_super) {
    __extends(MemoryStorageHandler, _super);

    function MemoryStorageHandler(metadataHandler) {
      MemoryStorageHandler.__super__.constructor.call(this, metadataHandler, {});
      this.className = "golab.ils.storage.MemoryStorageHandler";
      if (this._debug) {
        console.log("Initializing MemoryStorageHandler, debug: " + this._debug + ".");
      }
      this;
    }

    return MemoryStorageHandler;

  })(window.golab.ils.storage.ObjectStorageHandler);


  /*
    Implementation of a local (browser) storage handler.
   */

  goLabLocalStorageKey = "_goLab_";

  window.golab.ils.storage.LocalStorageHandler = (function(_super) {
    __extends(LocalStorageHandler, _super);

    function LocalStorageHandler(metadataHandler) {
      this.listAllResourcesForCaching = __bind(this.listAllResourcesForCaching, this);
      this.listResourceMetaDatas = __bind(this.listResourceMetaDatas, this);
      this.createResource = __bind(this.createResource, this);
      LocalStorageHandler.__super__.constructor.apply(this, arguments);
      this.className = "golab.ils.storage.LocalStorageHandler";
      if (this._debug) {
        console.log("Initializing LocalStorageHandler.");
      }
      this.localStorage = window.localStorage;
      this;
    }

    LocalStorageHandler.prototype.readResource = function(resourceId, cb) {
      var error;
      if (this.localStorage[goLabLocalStorageKey + resourceId]) {
        if (this._debug) {
          console.log("LocalStorageHandler: readResource " + resourceId);
        }
        return setTimeout((function(_this) {
          return function() {
            if (_this._debug) {
              console.log(_this.localStorage[goLabLocalStorageKey + resourceId]);
            }
            return cb(null, JSON.parse(_this.localStorage[goLabLocalStorageKey + resourceId]));
          };
        })(this), 0);
      } else {
        error = new Error("LocalStorageHandler: readResource " + resourceId + " not found.");
        if (this._debug) {
          console.log(error);
        }
        return setTimeout(function() {
          return cb(error);
        }, 0);
      }
    };

    LocalStorageHandler.prototype.resourceExists = function(resourceId, cb) {
      var exists;
      exists = this.localStorage[goLabLocalStorageKey + resourceId] !== void 0;
      return setTimeout(function() {
        return cb(null, exists);
      }, 0);
    };

    LocalStorageHandler.prototype.deleteResource = function(resourceId, cb) {
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      if (this.localStorage[goLabLocalStorageKey + resourceId] != null) {
        delete this.localStorage[goLabLocalStorageKey + resourceId];
        return setTimeout(function() {
          return cb(null);
        }, 0);
      } else {
        return setTimeout(function() {
          return cb(new Error("Can't delete resource - doesn't exist."));
        }, 0);
      }
    };

    LocalStorageHandler.prototype.createResource = function(content, cb) {
      var error, resource, resourceId;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      try {
        resource = this.getResourceBundle(content);
        resourceId = resource.metadata.id;
        if (this.localStorage[goLabLocalStorageKey + resourceId]) {
          error = new Error("LocalStorageHandler: resource already exists! " + resourceId);
          if (this._debug) {
            console.log(error);
          }
          return setTimeout(function() {
            return cb(error);
          }, 0);
        } else {
          this.localStorage[goLabLocalStorageKey + resourceId] = JSON.stringify(resource);
          if (this._debug) {
            console.log("LocalStorageHandler: resource created:");
          }
          if (this._debug) {
            console.log(resource);
          }
          return setTimeout(function() {
            return cb(null, resource);
          }, 0);
        }
      } catch (_error) {
        error = _error;
        error = new Error("LocalStorageHandler: resource NOT created: " + error);
        if (this._debug) {
          console.log(error);
        }
        return setTimeout(function() {
          return cb(error);
        }, 0);
      }
    };

    LocalStorageHandler.prototype.updateResource = function(resourceId, content, cb) {
      var error, resource;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      if (this.localStorage[goLabLocalStorageKey + resourceId]) {
        resource = this.getResourceBundle(content, resourceId);
        this.localStorage[goLabLocalStorageKey + resourceId] = JSON.stringify(resource);
        if (this._debug) {
          console.log("LocalStorageHandler: updateResource " + resourceId);
        }
        return setTimeout(function() {
          return cb(null, resource);
        }, 0);
      } else {
        error = new Error("LocalStorageHandler: updateResource failed, resource doesn't exist: " + resourceId);
        console.log(error);
        return setTimeout(function() {
          return cb(error);
        }, 0);
      }
    };

    LocalStorageHandler.prototype.isGoLabKey = function(key) {
      return key.indexOf(goLabLocalStorageKey) === 0;
    };

    LocalStorageHandler.prototype.listResourceIds = function(cb) {
      var id, ids, resourceString, stripPrefix;
      stripPrefix = function(id) {
        return id.substr(goLabLocalStorageKey.length);
      };
      ids = (function() {
        var _ref, _results;
        _ref = this.localStorage;
        _results = [];
        for (id in _ref) {
          resourceString = _ref[id];
          if (this.isGoLabKey(id)) {
            _results.push(stripPrefix(id));
          }
        }
        return _results;
      }).call(this);
      return setTimeout(function() {
        return cb(null, ids);
      }, 0);
    };

    LocalStorageHandler.prototype.listResourceMetaDatas = function(cb) {
      var id, metadatas, resource, resourceString, _ref;
      metadatas = [];
      _ref = this.localStorage;
      for (id in _ref) {
        resourceString = _ref[id];
        if (!(this.isGoLabKey(id))) {
          continue;
        }
        resource = JSON.parse(resourceString);
        metadatas.push({
          id: resource.metadata.id,
          metadata: resource.metadata
        });
      }
      metadatas = this.applyFilters(metadatas);
      return setTimeout(function() {
        return cb(null, metadatas);
      }, 0);
    };

    LocalStorageHandler.prototype.listAllResourcesForCaching = function(cb) {
      var id, metadatas, resource, resourceString, _ref;
      metadatas = [];
      _ref = this.localStorage;
      for (id in _ref) {
        resourceString = _ref[id];
        if (!(this.isGoLabKey(id))) {
          continue;
        }
        resource = JSON.parse(resourceString);
        metadatas.push({
          id: resource.metadata.id,
          metadata: resource.metadata
        });
      }
      return setTimeout(function() {
        return cb(null, metadatas);
      }, 0);
    };

    return LocalStorageHandler;

  })(window.golab.ils.storage.StorageHandler);


  /*
    Implementation of a Vault (Graasp/ILS) storage handler.
   */

  window.golab.ils.storage.VaultStorageHandler = (function(_super) {
    __extends(VaultStorageHandler, _super);

    function VaultStorageHandler(metadataHandler) {
      this.createResource = __bind(this.createResource, this);
      this.setConfiguration = __bind(this.setConfiguration, this);
      VaultStorageHandler.__super__.constructor.apply(this, arguments);
      this.className = "golab.ils.storage.VaultStorageHandler";
      if (this._debug) {
        console.log("Initializing VaultStorageHandler.");
      }
      if (typeof ils === "undefined" || ils === null) {
        throw "The ILS library needs to be present for the VaultStorageHandler";
      } else {
        this.configureFilters(true, true, false);
        return this;
      }
    }

    VaultStorageHandler.prototype.readResource = function(resourceId, cb) {
      var error;
      try {
        if (this.metadataHandler.getMetadata().target.objectType === "configuration") {
          return ils.getApp((function(_this) {
            return function(app) {
              var configuration;
              console.log("3333");
              console.log(app);
              if ((app.metadata != null) && (app.metadata.settings != null)) {
                configuration = ils.getFixedConfiguration(app.id, app.displayName, app.appUrl, app.metadata.settings, "undefined", "undefined", "undefined");
              } else {
                configuration = void 0;
              }
              return cb(null, configuration);
            };
          })(this));
        } else {
          return ils.readResource(resourceId, (function(_this) {
            return function(result) {
              var error, resource;
              if (result.error != null) {
                return cb(result.error);
              } else {
                if (_this._debug != null) {
                  console.log("ils.readResource returns:");
                }
                if (_this._debug != null) {
                  console.log(result);
                }
                resource = {};
                if (typeof result.metadata === 'object') {
                  resource.metadata = result.metadata;
                } else {
                  try {
                    resource.metadata = JSON.parse(result.metadata);
                  } catch (_error) {
                    error = _error;
                    console.warn("Could not parse metadata when reading a resource:");
                    console.warn(result.metadata);
                    cb(error);
                    return;
                  }
                }
                resource.metadata.id = resourceId;
                if (typeof result.content === 'object') {
                  resource.content = result.content;
                } else {
                  try {
                    resource.content = JSON.parse(result.content);
                  } catch (_error) {
                    error = _error;
                    console.warn("Could not parse content when reading a resource:");
                    console.warn(result.content);
                    cb(error);
                    return;
                  }
                }
                _this.metadataHandler.setId(resource.metadata.id);
                _this.metadataHandler.setTarget(resource.metadata.target);
                return cb(null, resource);
              }
            };
          })(this));
        }
      } catch (_error) {
        error = _error;
        console.warn("Something went wrong when trying to load resource " + resourceId + " from the vault:");
        console.warn(error);
        return cb(error);
      }
    };

    VaultStorageHandler.prototype.resourceExists = function(resourceId, cb) {
      var error;
      try {
        return ils.existResource(resourceId, (function(_this) {
          return function(result) {
            if (result.error != null) {
              return cb(result.error);
            } else {
              return cb(null, result);
            }
          };
        })(this));
      } catch (_error) {
        error = _error;
        console.warn("Something went wrong when trying to call 'resourceExists' from the vault:");
        console.warn(error);
        return cb(error);
      }
    };

    VaultStorageHandler.prototype.setConfiguration = function(content, cb) {
      var resource;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot set configuration.");
        }, 0);
        return;
      }
      try {
        resource = this.getResourceBundle(content);
        this.metadataHandler.setId(resource.metadata.id);
        if (this._debug != null) {
          console.log("Setting configuration resource in Vault:");
        }
        if (this._debug != null) {
          console.log(resource);
        }
        return ils.setAppConfiguration(resource.content, resource.metadata, (function(_this) {
          return function(result) {
            if (_this._debug != null) {
              console.log("ils.createConfigurationFile returns:");
            }
            if (result.error != null) {
              if (_this._debug != null) {
                console.log(result.error);
              }
              return cb(result.error);
            } else {
              if (_this._debug != null) {
                console.log(result);
              }
              return cb(null, resource);
            }
          };
        })(this));
      } catch (_error) {
        console.warn("Something went wrong when trying to create a configuration in the vault:");
        console.warn(error);
        return cb(error);
      }
    };

    VaultStorageHandler.prototype.createResource = function(content, cb) {
      var error, resource, resourceName;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      if (this._debug != null) {
        console.log("VaultStorageHandler.createResource called.");
      }
      if (this._debug != null) {
        console.log("... for type: " + (this.metadataHandler.getMetadata().target.objectType));
      }
      if (this.metadataHandler.getMetadata().target.objectType === "configuration") {
        return this.setConfiguration(content, cb);
      } else {
        try {
          console.log("Creating a new standard resource in Vault.");
          resource = this.getResourceBundle(content);
          resourceName = resource.metadata.target.displayName;
          resource.metadata.id = void 0;
          return ils.createResource(resourceName, resource.content, resource.metadata, (function(_this) {
            return function(result) {
              var error, returnedResource;
              if (_this._debug != null) {
                console.log("ils.createResource returns:");
              }
              if (_this._debug != null) {
                console.log(result);
              }
              if (result.error != null) {
                return cb(result.error);
              } else {
                returnedResource = {};
                returnedResource.content = resource.content;
                if (typeof result.metadata === 'object') {
                  returnedResource.metadata = result.metadata;
                } else {
                  try {
                    returnedResource.metadata = JSON.parse(result.metadata);
                  } catch (_error) {
                    error = _error;
                    console.warn("Something went wrong when trying to parse the returned resource's metadata:");
                    console.warn(resource.metadata);
                    cb(error);
                    return;
                  }
                }
                returnedResource.metadata.id = result.id;
                _this.metadataHandler.setId(returnedResource.id);
                return cb(null, returnedResource);
              }
            };
          })(this));
        } catch (_error) {
          error = _error;
          console.warn("Something went wrong when trying to create a resource in the vault:");
          console.warn(error);
          return cb(error);
        }
      }
    };

    VaultStorageHandler.prototype.updateResource = function(resourceId, content, cb) {
      var error, metadata, resource;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      if (this._debug != null) {
        console.log("VaultStorageHandler.updateResource called.");
      }
      if (this._debug != null) {
        console.log("... for type: " + (this.metadataHandler.getMetadata().target.objectType));
      }
      if (this.metadataHandler.getMetadata().target.objectType === "configuration") {
        return this.setConfiguration(content, cb);
      } else {
        try {
          resource = this.getResourceBundle(content);
          content = resource.content;
          metadata = resource.metadata;
          metadata.id = resourceId;
          return ils.updateResource(resourceId, content, metadata, (function(_this) {
            return function(result) {
              var error, updatedResource;
              if (_this._debug != null) {
                console.log("ils.updateResource returns:");
              }
              if (_this._debug != null) {
                console.log(result);
              }
              if (result.error != null) {
                return cb(result.error);
              } else {
                updatedResource = {};
                updatedResource.content = content;
                if ((typeof result.metadata) === 'object') {
                  updatedResource.metadata = result.metadata;
                } else {
                  try {
                    updatedResource.metadata = JSON.parse(result.metadata);
                  } catch (_error) {
                    error = _error;
                    console.error("Something went wrong when trying to parse the returned resource's metadata:");
                    console.error(result.metadata);
                    cb(error);
                  }
                }
                _this.metadataHandler.setId(updatedResource.metadata.id);
                return cb(null, updatedResource);
              }
            };
          })(this));
        } catch (_error) {
          error = _error;
          console.warn("Something went wrong when trying to update resource " + resourceId + " in the vault:");
          console.warn(error);
          return cb(error);
        }
      }
    };

    VaultStorageHandler.prototype.deleteResource = function(resourceId, cb) {
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      return this.readResource(resourceId, (function(_this) {
        return function(error, resource) {
          if ((error != null) || resource === "") {
            console.warn("Could not delete resource " + resourceId + ", because I couldn't load it to fetch its details.");
            return cb("Could not delete resource " + resourceId + ", because I couldn't load it to fetch its details.");
          } else if (resource.metadata.target.objectType === "configuration") {
            return console.warn("Cannot delete the configuration for appId " + resource.metadata.generator.id + ", feature not implemented.");
          } else {
            console.log("deleting a 'normal' resource.");
            try {
              return ils.deleteResource(resourceId, function(result) {
                if (_this._debug != null) {
                  console.log("ils.deleteResource returns:");
                }
                if (_this._debug != null) {
                  console.log(result);
                }
                if (result.error != null) {
                  return cb(result.error);
                } else {
                  return cb(null);
                }
              });
            } catch (_error) {
              error = _error;
              console.warn("Something went wrong when trying to delete resource " + resourceId + " in the vault:");
              console.warn(error);
              return cb(error);
            }
          }
        };
      })(this));
    };

    VaultStorageHandler.prototype.listResourceIds = function(cb) {
      throw "Not yet implemented.";
    };

    VaultStorageHandler.prototype._listResourceMetaDatas = function(forCaching, cb) {
      var error, filter;
      if (this.metadataHandler.getMetadata().target.objectType === "configuration") {
        return ils.getApp((function(_this) {
          return function(app) {
            var configuration, returnedMetadatas;
            returnedMetadatas = [];
            if ((app.metadata != null) && (app.metadata.settings != null)) {
              configuration = ils.getFixedConfiguration(app.id, app.displayName, app.appUrl, app.metadata.settings, "undefined", "undefined", "undefined");
              returnedMetadatas.push(configuration);
            }
            return cb(null, returnedMetadatas);
          };
        })(this));
      } else {
        try {
          filter = {};
          filter.vaultId = this.metadataHandler.getMetadata().storageId;
          if (this._filterForUser) {
            if (this.metadataHandler.getMetadata().contextualActor != null) {
              filter.userId = this.metadataHandler.getMetadata().contextualActor.id;
            } else {
              filter.userId = this.metadataHandler.getMetadata().actor.id;
            }
          } else {
            filter.userId = "";
          }
          if (this._filterForAppId) {
            filter.appId = this.metadataHandler.getMetadata().generator.id;
          } else {
            filter.appId = "";
          }
          if (this._filterForResourceType) {
            filter.objectType = this.metadataHandler.getMetadata().target.objectType;
          } else {
            filter.objectType = "";
          }
          filter.creationDateFrom = "";
          filter.creationDateTo = "";
          filter.lastModificationDateFrom = "";
          filter.lastModificationDateTo = "";
          return ils.filterVault(filter.vaultId, filter.userId, filter.appId, filter.objectType, filter.creationDateFrom, filter.creationDateTo, filter.lastModificationDateFrom, filter.lastModificationDateTo, (function(_this) {
            return function(result) {
              var error, item, resource, returnedMetadatas, _i, _len;
              if (_this._debug) {
                console.log("ils.filterVault returns:");
              }
              if (_this._debug) {
                console.log(result);
              }
              if (result.error != null) {
                if (result.error === "No resource available in the Vault.") {
                  return cb(null, []);
                } else {
                  return cb(result.error);
                }
              } else {
                returnedMetadatas = [];
                for (_i = 0, _len = result.length; _i < _len; _i++) {
                  resource = result[_i];
                  try {
                    item = {};
                    if (resource.metadata) {
                      item.id = resource.id;
                      if (typeof resource.metadata === 'object') {
                        item.metadata = resource.metadata;
                      } else {
                        item.metadata = JSON.parse(resource.metadata);
                      }
                      if ((item.metadata != null) && (item.metadata.target != null)) {
                        item.metadata.id = resource.id;
                        if (forCaching && resource.content) {
                          item.content = JSON.parse(resource.content);
                        }
                        returnedMetadatas.push(item);
                      }
                    }
                  } catch (_error) {
                    error = _error;
                    console.log("caught an error when parsing metadata from Vault");
                    console.log(error);
                  }
                }
                if (!forCaching) {
                  returnedMetadatas = _this.applyFilters(returnedMetadatas);
                }
                return cb(null, returnedMetadatas);
              }
            };
          })(this));
        } catch (_error) {
          error = _error;
          console.warn("Something went wrong when trying to list the resources in the vault:");
          console.warn(error);
          return cb(error);
        }
      }
    };

    VaultStorageHandler.prototype.listResourceMetaDatas = function(cb) {
      return this._listResourceMetaDatas(false, cb);
    };

    VaultStorageHandler.prototype.listAllResourcesForCaching = function(cb) {
      return this._listResourceMetaDatas(true, cb);
    };

    return VaultStorageHandler;

  })(window.golab.ils.storage.StorageHandler);


  /*
    Implementation of a MongoDB storage handler.
   */

  window.golab.ils.storage.MongoStorageHandler = (function(_super) {
    __extends(MongoStorageHandler, _super);

    function MongoStorageHandler(metadataHandler, _at_urlPrefix) {
      this.urlPrefix = _at_urlPrefix;
      this.listResourceMetaDatas = __bind(this.listResourceMetaDatas, this);
      this.createResource = __bind(this.createResource, this);
      MongoStorageHandler.__super__.constructor.call(this, metadataHandler, true, true, true);
      this.className = "golab.ils.storage.MongoStorageHandler";
      if (this.urlPrefix != null) {
        if (this._debug) {
          console.log("Initializing MongoStorageHandler.");
        }
        this;
      } else {
        console.error("I need an urlPrefix as second parameter.");
      }
    }

    MongoStorageHandler.prototype.readResource = function(resourceId, cb) {
      var error;
      try {
        return $.ajax({
          type: "GET",
          url: (this.urlPrefix + "/readResource/") + resourceId,
          contentType: "text/plain",
          crossDomain: true,
          success: function(resource) {
            if (this._debug) {
              console.log("GET readResource success, response:");
              console.log(resource);
            }
            return cb(null, resource);
          },
          error: function(responseData, textStatus, errorThrown) {
            console.warn("GET readResource failed, response:");
            console.warn(errorThrown);
            return cb(errorThrown);
          }
        });
      } catch (_error) {
        error = _error;
        console.warn("Something went wrong when retrieving the resource:");
        console.warn(error);
        return cb(error);
      }
    };

    MongoStorageHandler.prototype.deleteResource = function(resourceId, cb) {
      var error;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      try {
        return $.ajax({
          type: "POST",
          url: (this.urlPrefix + "/deleteResource/") + resourceId,
          crossDomain: true,
          success: function(response) {
            if (this._debug) {
              console.log("POST deleteResource success, response:");
              console.log(response);
            }
            return cb(null);
          },
          error: function(responseData, textStatus, errorThrown) {
            console.warn("POST deleteResource failed, response:");
            console.warn(errorThrown);
            return cb(errorThrown);
          }
        });
      } catch (_error) {
        error = _error;
        console.warn("Something went wrong when deleting the resource:");
        console.warn(error);
        return cb(error);
      }
    };

    MongoStorageHandler.prototype.resourceExists = function(resourceId, cb) {
      var error;
      try {
        return $.ajax({
          type: "GET",
          url: (this.urlPrefix + "/resourceExists/") + resourceId,
          crossDomain: true,
          contentType: "text/plain",
          success: function(result) {
            if (this._debug) {
              console.log("GET resourceExists success, response:");
              console.log(result);
            }
            return cb(void 0, true);
          },
          error: function(responseData, textStatus, errorThrown) {
            console.warn("GET resourceExists failed, response:");
            console.warn(responseData);
            if (responseData.status === 500) {
              return cb(errorThrown);
            } else if (responseData.status === 410) {
              return cb(void 0, false);
            }
          }
        });
      } catch (_error) {
        error = _error;
        console.warn("Something went wrong when retrieving the resource:");
        console.warn(error);
        return cb(error);
      }
    };

    MongoStorageHandler.prototype.createResource = function(content, cb) {
      var error, resource;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      try {
        resource = this.getResourceBundle(content);
        resource._id = resource.metadata.id;
        return $.ajax({
          type: "POST",
          url: this.urlPrefix + "/storeResource",
          data: JSON.stringify(resource),
          contentType: "text/plain",
          crossDomain: true,
          success: function(responseData, textStatus, jqXHR) {
            if (this._debug) {
              console.log("POST createResource success, response:");
              console.log(responseData);
            }
            delete resource._id;
            return cb(void 0, resource);
          },
          error: function(responseData, textStatus, errorThrown) {
            console.warn("POST createResource failed, response:");
            console.warn(responseData);
            return cb(responseData);
          }
        });
      } catch (_error) {
        error = _error;
        console.log("Something went wrong when writing to Mongo:");
        console.error(error);
        return cb(error);
      }
    };

    MongoStorageHandler.prototype.updateResource = function(resourceId, content, cb) {
      var error, resource;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      try {
        resource = this.getResourceBundle(content, resourceId);
        resource._id = resource.metadata.id;
        return $.ajax({
          type: "POST",
          url: this.urlPrefix + "/updateResource",
          data: JSON.stringify(resource),
          contentType: "text/plain",
          crossDomain: true,
          success: function(responseData, textStatus, jqXHR) {
            if (this._debug) {
              console.log("POST updateResource success, response:");
              console.log(responseData);
            }
            delete resource._id;
            return cb(null, resource);
          },
          error: function(responseData, textStatus, errorThrown) {
            console.warn("POST updateResource failed, response:");
            console.warn(responseData);
            return cb(responseData);
          }
        });
      } catch (_error) {
        error = _error;
        console.log("Something went wrong when updating to Mongo:");
        console.error(error);
        return cb(error);
      }
    };

    MongoStorageHandler.prototype.listResourceMetaDatas = function(cb) {
      var error;
      try {
        $.support.cors = true;
        return $.ajax({
          type: "GET",
          crossDomain: true,
          contentType: "text/plain",
          url: this.urlPrefix + "/listResourceMetaDatas",
          success: (function(_this) {
            return function(responseData) {
              if (_this._debug) {
                console.log("GET listResourceMetaDatas success, response (before filters):");
                console.log(responseData);
              }
              responseData = _this.applyFilters(responseData);
              return cb(void 0, responseData);
            };
          })(this),
          error: function(responseData, textStatus, errorThrown) {
            console.warn("GET listResourceMetaDatas failed, response:");
            console.warn(JSON.stringify(responseData));
            return cb(responseData);
          }
        });
      } catch (_error) {
        error = _error;
        console.warn("Something went wrong when retrieving the metedatas:");
        console.warn(error);
        return cb(error);
      }
    };

    MongoStorageHandler.prototype.listResourceIds = function(cb) {
      throw "Not yet implemented.";
    };

    return MongoStorageHandler;

  })(window.golab.ils.storage.StorageHandler);


  /*
    Implementation of a MongoDB-IIS storage handler.
   */

  window.golab.ils.storage.MongoIISStorageHandler = (function(_super) {
    __extends(MongoIISStorageHandler, _super);

    function MongoIISStorageHandler(metadataHandler, _at_urlPrefix) {
      this.urlPrefix = _at_urlPrefix;
      this.listAllResourcesForCaching = __bind(this.listAllResourcesForCaching, this);
      this.listResourceMetaDatas = __bind(this.listResourceMetaDatas, this);
      this._listResourceMetaDatas = __bind(this._listResourceMetaDatas, this);
      this.createResource = __bind(this.createResource, this);
      MongoIISStorageHandler.__super__.constructor.call(this, metadataHandler, true, true, true);
      this.className = "golab.ils.storage.MongoIISStorageHandler";
      if (this.urlPrefix != null) {
        if (this._debug) {
          console.log("Initializing MongoStorageHandler.");
        }
        this;
      } else {
        console.error("I need an urlPrefix as second parameter.");
      }
    }

    MongoIISStorageHandler.prototype.createResource = function(content, cb) {
      var error, resource;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      try {
        resource = this.getResourceBundle(content);
        resource._id = resource.metadata.id;
        return $.ajax({
          type: "POST",
          url: this.urlPrefix + "/storeResource.js",
          contentType: "text/plain",
          data: JSON.stringify(resource),
          crossDomain: true,
          success: function(responseData, textStatus, jqXHR) {
            if (this._debug) {
              console.log("POST createResource success, response:");
              console.log(responseData);
            }
            delete resource._id;
            return cb(void 0, resource);
          },
          error: function(responseData, textStatus, errorThrown) {
            console.warn("POST createResource failed, response:");
            console.warn(responseData);
            return cb(responseData);
          }
        });
      } catch (_error) {
        error = _error;
        console.log("Something went wrong when writing to Mongo:");
        console.error(error);
        return cb(error);
      }
    };

    MongoIISStorageHandler.prototype.updateResource = function(resourceId, content, cb, async) {
      var error, resource;
      if (async == null) {
        async = true;
      }
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      try {
        resource = this.getResourceBundle(content, resourceId);
        resource._id = resource.metadata.id;
        return $.ajax({
          async: async,
          type: "POST",
          url: this.urlPrefix + "/updateResource.js",
          data: JSON.stringify(resource),
          crossDomain: true,
          success: function(responseData, textStatus, jqXHR) {
            if (this._debug) {
              console.log("POST updateResource success, response:");
              console.log(responseData);
              console.log(textStatus);
              console.log(jqXHR);
            }
            delete resource._id;
            return cb(null, resource);
          },
          error: function(responseData, textStatus, errorThrown) {
            console.warn("POST updateResource failed, response:");
            console.warn(responseData);
            return cb(responseData);
          }
        });
      } catch (_error) {
        error = _error;
        console.log("Something went wrong when updating to Mongo:");
        console.error(error);
        return cb(error);
      }
    };

    MongoIISStorageHandler.prototype._listResourceMetaDatas = function(filterString, applyLocalFilters, cb) {
      var error, urlString;
      try {
        urlString = "/listMetadatas.js";
        if (filterString != null) {
          urlString = urlString + "?" + filterString;
        }
        return $.ajax({
          type: "GET",
          crossDomain: true,
          contentType: "text/plain",
          url: this.urlPrefix + urlString,
          success: (function(_this) {
            return function(responseData) {
              var metadatas;
              if (_this._debug) {
                console.log("GET listResourceMetaDatas success, response (before filters):");
                console.log(responseData);
              }
              metadatas = applyLocalFilters ? _this.applyFilters(responseData) : responseData;
              return cb(void 0, metadatas);
            };
          })(this),
          error: function(responseData, textStatus, errorThrown) {
            console.warn("GET listResourceMetaDatas failed, response:");
            console.warn(JSON.stringify(responseData));
            return cb(responseData);
          }
        });
      } catch (_error) {
        error = _error;
        console.warn("Something went wrong when retrieving the metedatas:");
        console.warn(error);
        return cb(error);
      }
    };

    MongoIISStorageHandler.prototype.listResourceMetaDatas = function(cb) {
      var filterString;
      filterString = "";
      if (this._filterForProvider) {
        filterString = "providerId=" + (this.metadataHandler.getProvider().id);
      }
      if (this._filterForUser) {
        if (filterString != null) {
          filterString = filterString + "&";
        }
        filterString = filterString + ("actorId=" + (this.metadataHandler.getActor().id));
      }
      return this._listResourceMetaDatas(filterString, true, cb);
    };

    MongoIISStorageHandler.prototype.listAllResourcesForCaching = function(cb) {
      var filterString;
      filterString = "";
      if (this._filterForProvider) {
        filterString = "providerId=" + (this.metadataHandler.getProvider().id);
      }
      return this._listResourceMetaDatas(filterString, false, cb);
    };

    MongoIISStorageHandler.prototype.readResource = function(resourceId, cb) {
      var error;
      try {
        return $.ajax({
          type: "GET",
          url: (this.urlPrefix + "/readResource.js?id=") + resourceId,
          crossDomain: true,
          success: function(resource) {
            if (this._debug) {
              console.log("GET readResource success, response:");
              console.log(resource);
            }
            delete resource._id;
            return cb(null, resource);
          },
          error: function(responseData, textStatus, errorThrown) {
            console.warn("GET readResource failed, response:");
            console.warn(errorThrown);
            return cb(errorThrown);
          }
        });
      } catch (_error) {
        error = _error;
        console.warn("Something went wrong when retrieving the resource:");
        console.warn(error);
        return cb(error);
      }
    };

    MongoIISStorageHandler.prototype.deleteResource = function(resourceId, cb) {
      var error;
      if (this.isReadOnly()) {
        setTimeout(function() {
          return cb("StorageHandler is readOnly, cannot create resource.");
        }, 0);
        return;
      }
      try {
        return $.ajax({
          type: "POST",
          url: (this.urlPrefix + "/deleteResource.js?id=") + resourceId,
          crossDomain: true,
          success: function(response) {
            if (this._debug) {
              console.log("POST deleteResource success, response:");
              console.log(response);
            }
            return cb(null);
          },
          error: function(responseData, textStatus, errorThrown) {
            console.warn("POST deleteResource failed, response:");
            console.warn(errorThrown);
            return cb(errorThrown);
          }
        });
      } catch (_error) {
        error = _error;
        console.warn("Something went wrong when deleting the resource:");
        console.warn(error);
        return cb(error);
      }
    };

    MongoIISStorageHandler.prototype.resourceExists = function(resourceId, cb) {
      var error;
      try {
        return $.ajax({
          type: "GET",
          url: (this.urlPrefix + "/resourceExists.js?id=") + resourceId,
          crossDomain: true,
          success: function(result) {
            if (this._debug) {
              console.log("GET resourceExists success, response:");
              console.log(result);
            }
            return cb(void 0, true);
          },
          error: function(responseData, textStatus, errorThrown) {
            console.warn("GET resourceExists failed, response:");
            console.warn(responseData);
            if (responseData.status === 500) {
              return cb(errorThrown);
            } else if (responseData.status === 410) {
              return cb(void 0, false);
            }
          }
        });
      } catch (_error) {
        error = _error;
        console.warn("Something went wrong when retrieving the resource:");
        console.warn(error);
        return cb(error);
      }
    };

    return MongoIISStorageHandler;

  })(window.golab.ils.storage.StorageHandler);

  window.golab.ils.storage.utils = window.golab.ils.storage.utils || {};

  ErrorHandler = (function() {
    function ErrorHandler(_at_errors, _at_languageHandler, _at_logError) {
      this.errors = _at_errors;
      this.languageHandler = _at_languageHandler;
      this.logError = _at_logError;
    }

    ErrorHandler.prototype.reportError = function(displayMessage, consoleMessage) {
      if (!consoleMessage) {
        consoleMessage = displayMessage;
      }
      if (this.logError) {
        console.error(consoleMessage);
      }
      return this.errors.push({
        display: displayMessage,
        message: consoleMessage
      });
    };

    ErrorHandler.prototype.reportErrorKey = function() {
      var errorMessage, key, parameters, _ref;
      key = arguments[0], parameters = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      errorMessage = this.languageHandler ? (_ref = this.languageHandler).getMessage.apply(_ref, [key].concat(__slice.call(parameters))) : key;
      return this.reportError(errorMessage);
    };

    return ErrorHandler;

  })();

  window.golab.ils.storage.utils.validateResourceJson = function(resourceJson, languageHandler, logErrors, errors) {
    var errorHandler;
    if (languageHandler == null) {
      languageHandler = null;
    }
    if (logErrors == null) {
      logErrors = true;
    }
    if (errors == null) {
      errors = [];
    }
    errorHandler = new ErrorHandler(errors, languageHandler, logErrors);
    if (typeof resourceJson !== "object") {
      errorHandler.reportErrorKey("resourceJson.failure.noObject");
    }
    if (!resourceJson.metadata) {
      errorHandler.reportErrorKey("resourceJson.failure.noMetadata");
    }
    if (!resourceJson.content) {
      errorHandler.reportErrorKey("resourceJson.failure.noContent");
    }
    return errors;
  };

  window.golab.ils.storage.utils.validateResourceJsonArray = function(resourceJsonArray, languageHandler, logErrors, errors) {
    var errorHandler, resourceJson, _i, _len;
    if (languageHandler == null) {
      languageHandler = null;
    }
    if (logErrors == null) {
      logErrors = true;
    }
    if (errors == null) {
      errors = [];
    }
    errorHandler = new ErrorHandler(errors, languageHandler, logErrors);
    if (!Array.isArray(resourceJsonArray)) {
      errorHandler.reportErrorKey("resourceJson.failure.noArray");
    } else {
      for (_i = 0, _len = resourceJsonArray.length; _i < _len; _i++) {
        resourceJson = resourceJsonArray[_i];
        window.golab.ils.storage.utils.validateResourceJson(resourceJson, languageHandler, logErrors, errors);
      }
    }
    return errors;
  };

  window.golab.ils.storage.utils.importResourceJson = function(storageHandler, resourceJson, languageHandler, callback) {
    var error, originalMetadataString, resourceTitle;
    originalMetadataString = JSON.stringify(storageHandler.getMetadataHandler().getMetadata());
    resourceTitle = "";
    if (resourceJson && resourceJson.metadata.target && resourceJson.metadata.target.displayName) {
      resourceTitle = resourceJson.metadata.target.displayName;
    }
    storageHandler.getMetadataHandler().setMetadata(resourceJson.metadata);
    try {
      return storageHandler.createResource(resourceJson.content, function(error, resource) {
        var unexpectedError;
        try {
          storageHandler.getMetadataHandler().setMetadata(JSON.parse(originalMetadataString));
          if (error) {
            return callback({
              display: languageHandler.getMessage("resourceImport.failure.createResource", resourceTitle, error),
              message: "Failed to create resource (name=" + resourceTitle + "): " + (JSON.stringify(error))
            });
          } else {
            return callback(null, resource.metadata.id);
          }
        } catch (_error) {
          unexpectedError = _error;
          return callback({
            display: languageHandler.getMessage("resourceImport.failure.createResource.inCallback.unexpected", resourceTitle, unexpectedError),
            message: "Unexpected error in callback of create resource (name=" + resourceTitle + "): " + (JSON.stringify(unexpectedError))
          });
        }
      });
    } catch (_error) {
      error = _error;
      storageHandler.getMetadataHandler().setMetadata(JSON.parse(originalMetadataString));
      return callback({
        display: languageHandler.getMessage("resourceImport.failure.createResource.unexpected", resourceTitle, error),
        message: "Unexpected error during resource import (name=" + resourceTitle + "): " + (JSON.stringify(error))
      });
    }
  };

  window.golab.ils.storage.utils.importResourceJsonArray = function(storageHandler, resourceJsonArray, overwrite, languageHandler, callback) {
    var allTargetIds, currentForProviderFilter, currentForResourceTypeFilter, errors, exception, finishedLoading, getExistingResourceMetadata, getTargetId, importNextResource, jsonArray, loadedResourceIds, setAllTargetIds;
    errors = [];
    loadedResourceIds = [];
    allTargetIds = {};
    getTargetId = function(resourceJson) {
      if (resourceJson.metadata.target && resourceJson.metadata.target.id) {
        return resourceJson.metadata.target.id;
      } else {
        return null;
      }
    };
    setAllTargetIds = function(allMetadatas) {
      var metadata, targetId, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = allMetadatas.length; _i < _len; _i++) {
        metadata = allMetadatas[_i];
        targetId = getTargetId(metadata);
        if (targetId) {
          _results.push(allTargetIds[targetId] = metadata);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    getExistingResourceMetadata = function(resourceJson) {
      var targetId;
      targetId = getTargetId(resourceJson);
      if (targetId) {
        return allTargetIds[targetId];
      } else {
        return null;
      }
    };
    jsonArray = resourceJsonArray;
    finishedLoading = function() {
      return callback(errors, loadedResourceIds);
    };
    importNextResource = function() {
      var existingResourceMetadata, importResource, resourceJson;
      if (jsonArray.length) {
        resourceJson = jsonArray.pop();
        existingResourceMetadata = getExistingResourceMetadata(resourceJson);
        if (!existingResourceMetadata || overwrite) {
          importResource = function() {
            return window.golab.ils.storage.utils.importResourceJson(storageHandler, resourceJson, languageHandler, function(error, resourceId) {
              if (error) {
                errors.push(error);
              } else {
                loadedResourceIds.push(resourceId);
              }
              return importNextResource();
            });
          };
          if (existingResourceMetadata) {
            return storageHandler.deleteResource(existingResourceMetadata.metadata.id, function(error) {
              var resourceTitle;
              if (error) {
                resourceTitle = "";
                if (resourceJson && resourceJson.metadata.target && resourceJson.metadata.target.displayName) {
                  resourceTitle = resourceJson.metadata.target.displayName;
                }
                errors.push({
                  display: languageHandler.getMessage("resourceImport.failure.deleteResource", resourceTitle, error),
                  message: "Failed to delete resource (name=" + resourceTitle + "): " + (JSON.stringify(error))
                });
                return importNextResource();
              } else {
                return importResource();
              }
            });
          } else {
            return importResource();
          }
        } else {
          return importNextResource();
        }
      } else {
        return finishedLoading();
      }
    };
    currentForResourceTypeFilter = storageHandler.getForResourceTypeFilter();
    currentForProviderFilter = storageHandler.getForProviderFilter();
    storageHandler.setForResourceTypeFilter(false);
    storageHandler.setForProviderFilter(false);
    try {
      return storageHandler.listResourceMetaDatas(function(error, metadatas) {
        storageHandler.setForResourceTypeFilter(currentForResourceTypeFilter);
        storageHandler.setForProviderFilter(currentForProviderFilter);
        if (error) {
          errors.push({
            display: languageHandler.getMessage("resourceImport.failure.listResourceMetaDatas", error),
            message: "Failed to load list of resource metadatas: " + (JSON.stringify(error))
          });
          return finishedLoading();
        } else {
          setAllTargetIds(metadatas);
          return importNextResource();
        }
      });
    } catch (_error) {
      exception = _error;
      storageHandler.setForResourceTypeFilter(currentForResourceTypeFilter);
      errors.push({
        display: languageHandler.getMessage("resourceImport.failure.listResourceMetaDatas.unexpected", exception),
        message: "Unexpected error during load list of resource metadatas: " + (JSON.stringify(exception))
      });
      return finishedLoading();
    }
  };

  window.golab.ils.storage.utils.importFromUrl = function(storageHandler, url, overwrite, languageHandler, callback) {
    var error;
    try {
      return $.ajax({
        async: true,
        type: "GET",
        url: url,
        crossDomain: true,
        success: function(responseData, textStatus, jqXHR) {
          var resourceJsonArray, validationsErrors;
          resourceJsonArray = responseData;
          validationsErrors = window.golab.ils.storage.utils.validateResourceJsonArray(resourceJsonArray, languageHandler);
          if (validationsErrors.length === 0) {
            return window.golab.ils.storage.utils.importResourceJsonArray(storageHandler, resourceJsonArray, overwrite, languageHandler, callback);
          } else {
            return callback(validationsErrors, []);
          }
        },
        error: function(responseData, textStatus, errorThrown) {
          return callback([
            {
              display: languageHandler.getMessage("resourceImport.failure.loadJson", url, errorThrown),
              message: "Failed to load json from " + url + ": " + (JSON.stringify(errorThrown))
            }
          ]);
        }
      });
    } catch (_error) {
      error = _error;
      return callback([
        {
          display: languageHandler.getMessage("resourceImport.failure.loadJson.unexpected", url, error),
          message: "Unexpected error during load json from " + url + ": " + (JSON.stringify(error))
        }
      ]);
    }
  };

  window.golab.ils.storage.utils.simpleImportFromUrl = function(storageHandler, url, overwrite, languageHandler, callback) {
    return window.golab.ils.storage.utils.importFromUrl(storageHandler, url, overwrite, languageHandler, function(errors, loadedResourceIds) {
      var error, _i, _len;
      for (_i = 0, _len = errors.length; _i < _len; _i++) {
        error = errors[_i];
        console.error(error.message);
      }
      if (loadedResourceIds) {
        console.log("loaded " + loadedResourceIds.length + " resources");
      }
      return callback();
    });
  };

  window.golab.ils.storage.utils.loadPreviewResources = function(metadataHandler, storageHandler, languageHandler, previewResourcesUrl, callback, loadResources) {
    if (loadResources == null) {
      loadResources = true;
    }
    if (loadResources && metadataHandler.getContext() === window.golab.ils.context.preview) {
      return window.golab.ils.storage.utils.simpleImportFromUrl(storageHandler, previewResourcesUrl, false, languageHandler, callback);
    } else {
      return callback();
    }
  };

}).call(this);

//# sourceMappingURL=StorageHandler.js.map
